// 1. Напишите функцию deepEqual для проверки двух обьектов на идентичность. 

// мы создаём функцию, которая принимает два обьекта на проверку
function deepEqual(obj1, obj2) {
    // Cначала мы проверяем идентичны ли два обьекта по ссылке, если они идентичны 
    // то сразу возвращается true
    if (obj1 === obj2) {
        return true;
    }

    // Затем мы убеждаемся, что оба типа являются обьектами и не равны нулю
    if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || obj1 === null || obj2 === null) {
        return false;
    }

    // Далее мы получаем ключи обьектов и кладем их в массивы под каждый обьект соответсвующе
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);

    // Далее мы сравниваем массивы с ключами, если количество ключей в них не равно, то мы получим false
    if (keys1.length !== keys2.length) {
        return false;
    }

    // Далее мы перебираем каждый ключ в одном массиве для проверки, есть ли такой ключ в другом массиве,
    // с помощью цикла for...of
    //и рекурсивно вызываем нашу функцию для сравнения значений
    for (const key of keys1) {
        if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
            return false;
        }
    }

    return true;
}
//****************************************************

//2. Напишите функцию генератор chunkArray, которая возвращает 
//   итератор возвращающий части массива указанной длинны.

//Создаём функцию, которая будет принимать массив и размер, на который нужно разделить наш массив
function chunkArray(arr, chunkSize) {
    //Создаём начальный индекс
    let index = 0;
    //Цикл будет работать до тех пор, пока наш индекс будет меньше длины массива
    while (index < arr.length) {
        //Мы используем slice для разделения массива на части и с помощью оператора yield мы отправляем 
        //полученое значение, останавливаем наш цикл пока не вызовем next()
        yield arr.slice(index, index + chunkSize);
        index += chunkSize;
    }
}
//И когда весь массив будет разделён на нужные части и в массиве не останется больше ничего, 
//то наша функция вернет true

//****************************************************

//3. Напишите функцию обертку, которая на вход принимает массив функций и их 
//параметров, а возвращает массив результатов их выполнения. Количество аргументов исполняемой 
//функции не ограничено!

function bulkRun(functionsAndParams) {
    // Создаем пустой массив для хранения результатов выполнения функций
    const results = [];

    // Создаем функцию для выполнения одной функции
    function runFunction([func, params]) {
        return new Promise((resolve) => {
            // Выполняем функцию с переданными параметрами
            func(...params, (result) => {
                // Добавляем результат выполнения в массив результатов
                results.push(result);
                // Разрешаем промис для продолжения цепочки
                resolve();
            });
        });
    }

    // Создаем массив с промисами для выполнения всех функций поочередно
    const promises = functionsAndParams.map((funcAndParams) => runFunction(funcAndParams));

    // Возвращаем промис после выполнения всех функций
    return Promise.all(promises).then(() => results);
}

//****************************************************

//4. Напишите метод arrayToObject, который превращает массив в объект (использовать рекурсию). 

function arrayToObject(arr) {
    // Создаем пустой объект, в который будет складываться результат
    const obj = {};

    // Перебираем массив с помощью цикла for...of
    for (const [key, value] of arr) {
        // Проверяем, является ли значение массивом
        if (Array.isArray(value)) {
            // Если это массив, рекурсивно вызываем нашу функцию
            obj[key] = arrayToObject(value);
        } else {
            // Если значение не массив,то добавляем его в объект
            obj[key] = value;
        }
    }

    // Возвращаем объект, который мы создали в начале
    return obj;
}

//****************************************************

//5. Написать обратный метод (см. задачу 4) objectToArray, который из объекта создаст массив. 

function objectToArray(obj) {
    // Создаем пустой массив, в который будет складываться результат
    const arr = [];

    // Перебираем массив с помощью цикла for...in
    for (const key in obj) {
        // Исключаем ключи, унаследованные от прототипа
        if (obj.hasOwnProperty(key)) {
            // Создаем новый массив, содержащий ключ и соответствующее значение
            arr.push([key, obj[key]]);
        }
    }

    // Возвращаем полученный массив
    return arr;
}

//****************************************************

// 6. Есть функция primitiveMultiply, которая умножает числа, но случайным образом может выбрасывать 
// исключения типа: NotificationException, ErrorException. Задача написать функцию обертку которая будет 
// повторять вычисление  при исключении NotificationException, но прекращать работу при исключениях 
// ErrorException

function NotificationException() { }
function ErrorException() { }

function primitiveMultiply(a, b) {
    // Генерируем рандомное число от 0 до 1
    const rand = Math.random();
    // Если число меньше 0.5, возвращаем произведение a и b
    if (rand < 0.5) {
        return a * b;
    } else if (rand > 0.85) {
        // Если число больше 0.85, то вызываем ErrorException
        throw new ErrorException();
    } else {
        // В остальных случаях выбрасываем NotificationException
        throw new NotificationException();
    }
}

function reliableMultiply(a, b) {
    // Делаем бесконечный цикл
    while (true) {
        try {
            // Вызываем primitiveMultiply(a, b)
            return primitiveMultiply(a, b);
        } catch (error) {
            // Если возникла ошибка
            if (error instanceof ErrorException) {
                // Завершаем цикл
                throw error;
            } else if (error instanceof NotificationException) {
                // Выводим сообщение и продолжаем цикл
                console.log('NotificationException');
            } else {
                // Если что-то другое выбрасываем ошибку
                throw error;
            }
        }
    }
}

//****************************************************

// 7.  Напишите функцию, которая берет объект любой вложенности и преобразует ее в единую плоскую карту 
// с разными уровнями, разделенными косой чертой ( '/').


//Создаем функцию, которая принимает обьект и пустую строку которую мы добавим
function mapObject(obj, main = '') {
    // Создаем пустой объект для результата
    const result = {};

    // Прходимся по ключам объекта obj с помощью цикла
    for (const key in obj) {
        // Проверяем, принадлежит ли ключ объекту, а не его прототипу
        if (obj.hasOwnProperty(key)) {
            // создаем ключ 
            const currentKey = main ? `${main}/${key}` : key;

            // Проверяем, является ли значение ключа объектом (не массивом)
            if (typeof obj[key] === 'object' && !Array.isArray(obj[key])) {
                // Если объект, рекурсивно вызываем mapObject 
                Object.assign(result, mapObject(obj[key], currentKey));
            } else {
                // Если значение не является объектом, добавляем его в результат
                result[currentKey] = obj[key];
            }
        }
    }

    // Возвращаем результат
    return result;
}

//****************************************************

// 8. Напишите функцию combos, которая принимает положительное целое число num и возвращает массив 
// массивов положительных целых чисел, где сумма каждого массива равна  num.  Массивы не должны повторяться.

function combos(num) {
    // Создаем пустой массив для результата
    const results = [];
    //Создаем функцию которая принимает оставшуюся сумму и текущую комбинацию 
    function findCombinations(remaining, currentCombo) {
        // Если осталось суммировать 0, добавляем текущую комбинацию в результат
        if (remaining === 0) {
            results.push(currentCombo);
        } else if (remaining > 0) {
            // Если осталась положительная сумма, ищем комбинации
            for (let i = 1; i <= remaining; i++) {
                // Добавляем текущее число в комбинацию и рекурсивно ищем остальные комбинации
                findCombinations(remaining - i, [...currentCombo, i]);
            }
        }
    }

    // Начинаем поиск комбинаций, начиная с суммы num и пустой комбинации
    findCombinations(num, []);

    // Возвращаем результат
    return results;
}

//****************************************************

//9.  Напишите функцию add, которая бы работала следующим образом add(1)(2)(7)...(n). 
//Количество последовательных визовов неограничено.

function add(num) {
    // Создаем внутреннюю функцию, которая будет вызываться при каждом вызове add
    function innerAdd(nextNum) {
        // Если nextNum не определено или nextNum - не число, возвращаем innerAdd
        if (typeof nextNum !== 'undefined' && !isNaN(nextNum)) {
            // Если передано число, складываем его с предыдущими значениями num
            num += nextNum;
            return innerAdd;
        } else {
            // Если ничего не передано, возвращаем текущее значение num
            return num;
        }
    }

    // Возвращаем innerAdd
    return innerAdd;
}













